<!--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
  Copyright Â© 2019-2023 Metreeca srl

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~-->

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <META http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <title>oroboro &gt;
            tutorial</title>
        <link rel="stylesheet" type="text/css" href="style/default.css">
    </head>
    <body><a name="@top"></a>
        <div class="header links">
            <address><a href="http://www.oroboro.net/">oroboro</a></address>
            <ul>
                <li><a href="about.html">about</a></li>
                <li class="selected"><a href="tutorial.html">tutorial</a></li>
                <li><a href="handbook.html">handbook</a></li>
                <li><a href="api/index.html">api</a></li>
                <li><a href="http://code.google.com/p/oroboro/downloads/list">downloads</a></li>
                <li><a href="http://groups.google.com/group/oroboro-discuss">forum</a></li>
                <li class="version"><a href="news.html#2011.03.10">v0.6 / 20110310</a></li>
            </ul>
        </div>
        <div class="toc links">
            <div class="title">Tutorial</div>
            <h1><a href="#Graphs">Graphs</a></h1><h2><a href="#Nodes">Nodes</a></h2><h3><a href="#Creating nodes">Creating
            nodes</a></h3><h3><a href="#Accessing lexical forms and datatypes">Accessing lexical forms and datatypes</a>
        </h3><h3><a href="#Testing datatypes">Testing datatypes</a></h3><h3><a href="#Accessing values">Accessing
            values</a></h3><h3><a href="#Accessing typed values">Accessing typed values</a></h3><h2><a href="#Edges">Edges</a>
        </h2><h3><a href="#Creating edges">Creating edges</a></h3><h3><a href="#Inserting edges into graphs">Inserting
            edges into graphs</a></h3><h3><a href="#Removing edges from graphs">Removing edges from graphs</a></h3><h2>
            <a href="#Patterns">Patterns</a></h2><h3><a href="#Iterating over graph edges matching a pattern">Iterating
            over graph edges matching a pattern</a></h3><h3><a href="#Removing graph edges matching a pattern">Removing
            graph edges matching a pattern</a></h3><h1><a href="#Codecs">Codecs</a></h1><h2><a href="#Endpoints">Endpoints</a>
        </h2><h3><a href="#Defining input origins">Defining input origins</a></h3><h3><a href="#Defining output targets">Defining
            output targets</a></h3><h3><a href="#Accessing endpoints">Accessing endpoints</a></h3><h3>
            <a href="#Accessing Java resources">Accessing Java resources</a></h3><h2><a href="#Decoders">Decoders</a>
        </h2><h2><a href="#Encoders">Encoders</a></h2><h2><a href="#Guessing">Guessing</a></h2><h2><a href="#Catalogs">Catalogs</a>
        </h2><h3><a href="#Controlling namespace prefixes">Controlling namespace prefixes</a></h3><h3>
            <a href="#Reusing prefixes declared by input origins">Reusing prefixes declared by input origins</a></h3><h2>
            <a href="#Morphing">Morphing</a></h2><h1>
            <a href="#XML/XSLT"><acronym>XML/</acronym><acronym>XSLT</acronym></a></h1><h2><a href="#Transformers">Transformers</a>
        </h2><h2><a href="#Transcribers">Transcribers</a></h2><h2><a href="#Morphing">Morphing</a></h2><h2>
            <a href="#Integration">Integration</a></h2><h3><a href="#Integrating with Java XML Transforms"><acronym>Integrating
            with </acronym><acronym>Java XML Transforms</acronym></a></h3><h3>
            <a href="#Integrating with SAX-based tools"><acronym>Integrating </acronym>with <acronym>SAX-based
                tools</acronym></a></h3><h3><a href="#Integrating with DOM-based tools"><acronym>Integrating </acronym>with
            <acronym>DOM-based tools</acronym></a></h3><h1><a href="#Queries">Queries</a></h1><h2><a href="#Navigation">Navigation</a>
        </h2><h3><a href="#Creating and initializing queries">Creating and initializing queries</a></h3><h3>
            <a href="#Following links">Following links</a></h3><h3><a href="#Following links from multiple query nodes">Following
            links from multiple query nodes</a></h3><h3><a href="#Navigation patterns">Navigation patterns</a></h3><h3>
            <a href="#Navigating with constraints">Navigating with constraints</a></h3><h3>
            <a href="#Navigating with constraint filters">Navigating with constraint filters</a></h3><h3>
            <a href="#Multiple hops">Multiple hops</a></h3><h3><a href="#Complex structures">Complex structures</a></h3>
            <h2><a href="#Filtering">Filtering</a></h2><h2><a href="#Ordering">Ordering</a></h2><h2><a href="#Results">Results</a>
        </h2><h3><a href="#%C2%A0Retrieving nodes collections">&nbsp;Retrieving nodes collections</a></h3><h3>
            <a href="#%C2%A0Retrieving nodes">&nbsp;Retrieving nodes</a></h3><h3><a href="#Splitting queries">Splitting
            queries</a></h3><h1><a href="#Datalog">Datalog</a></h1><h2><a href="#Programs">Programs</a></h2><h3>
            <a href="#Parsing and assembling programs">Parsing and assembling programs</a></h3><h3>
            <a href="#Compiling and executing programs">Compiling and executing programs</a></h3><h2><a href="#Matching">Matching</a>
        </h2><h2><a href="#Querying">Querying</a></h2><h3><a href="#Composing complex patterns">Composing complex
            patterns</a></h3><h3><a href="#Organizing matches">Organizing matches</a></h3><h3>
            <a href="#Filtering matches">Filtering matches</a></h3><h3><a href="#Computing values">Computing values</a>
        </h3><h2><a href="#Inferencing">Inferencing</a></h2><h3><a href="#Backing queries with rules">Backing queries
            with rules</a></h3><h3><a href="#OWL reasoning"><acronym>OWL</acronym><acronym> </acronym>reasoning</a></h3>
            <h2><a href="#Updating">Updating</a></h2><h3><a href="#Inserting edges">Inserting edges</a></h3><h3>
            <a href="#Removing edges">Removing edges</a></h3><h3><a href="#Adding assumptions">Adding assumptions</a>
        </h3><h2><a href="#Verifying">Verifying</a></h2><h2><a href="#Morphing">Morphing</a></h2><h2>
            <a href="#Extending">Extending</a></h2><h3><a href="#Defining custom functions">Defining custom functions</a>
        </h3><h3><a href="#Calling custom functions">Calling custom functions</a></h3><h3>
            <a href="#Aggregate and multi-valued custom functions">Aggregate and multi-valued custom functions</a></h3>
            <h1><a href="#Shell">Shell</a></h1><h2><a href="#Interacting">Interacting</a></h2><h3>
            <a href="#Importing data">Importing data</a></h3><h3><a href="#Executing queries">Executing queries</a></h3>
            <h3><a href="#Updating data">Updating data</a></h3><h3><a href="#Exporting data">Exporting data</a></h3><h2>
            <a href="#Scripting">Scripting</a></h2><h3><a href="#Converting RDF documents">Converting RDF documents</a>
        </h3><h3><a href="#Updating RDF documents">Updating RDF documents</a></h3><h1><a href="#Datatypes">Datatypes</a>
        </h1><h2><a href="#Mappings">Mappings</a></h2><h3><a href="#Mapping nodes to values">Mapping nodes to values</a>
        </h3><h3><a href="#Mapping values to nodes">Mapping values to nodes</a></h3><h3>
            <a href="#Mapping nodes to lexical forms">Mapping nodes to lexical forms</a></h3><h3>
            <a href="#Mapping lexical forms to nodes">Mapping lexical forms to nodes</a></h3><h3>
            <a href="#Mapping lexical forms to values">Mapping lexical forms to values</a></h3><h3>
            <a href="#Mapping values to lexical forms">Mapping values to lexical forms</a></h3><h2>
            <a href="#Inheritance">Inheritance</a></h2><h2><a href="#Plugging">Plugging</a></h2><h3>
            <a href="#Resolving datatype URIs">Resolving datatype <acronym>URI</acronym>s</a></h3><h3>
            <a href="#Defining datatype objects">Defining datatype objects</a></h3><h3>
            <a href="#Registering datatype objects">Registering datatype objects</a></h3><h3>
            <a href="#Custom datatypes in action">Custom datatypes in action</a></h3></div>
        <div class="contents"><!--[if lt IE 8]>
            <div class="note">Best viewed with <a
                    href="http://www.microsoft.com/windows/internet-explorer/"
            >Internet Explorer 8+</a>
            </div>
            <![endif]--><h1>Introduction</h1><p>This tutorial provides an example-driven introduction to the Oroboro Java
                RDF processing framework. It assumes a basic understanding of the RDF abstract model and other common RDF
                concepts, such as serialization to textual formats. To get started,
                <a href="http://code.google.com/p/oroboro/downloads/list">download</a> the latest binary distribution,
                unpack it and add <code>lib/oroboro.jar</code> to your classpath.</p>
            <pre>@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt;.
@prefix dc:   &lt;http://purl.org/dc/elements/1.1/&gt;.
@prefix rdf:  &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt;.
@prefix xsd:  &lt;http://www.w3.org/2001/XMLSchema#&gt;.

[] a foaf:Person;
    foaf:name "Libertino Faussone";
    foaf:nick "Tino";
    foaf:age 35;
    foaf:interest &lt;http://en.wikipedia.org/wiki/Narrative&gt;;
    foaf:interest &lt;http://en.wikipedia.org/wiki/Construction&gt;;
    foaf:knows [
        foaf:name "Primo Levi";
        foaf:age 59;
        foaf:interest &lt;http://en.wikipedia.org/wiki/Narrative&gt;;
        foaf:interest &lt;http://en.wikipedia.org/wiki/Chemistry&gt;;
        foaf:made [
            dc:title "La chiave a stella", "The wrench"@en;
            dc:date "1978"
        ], [
            dc:title "L'altrui mestiere", "Other People's Trades"@en;
            dc:date "1985"
        ]
    ], [
        foaf:name "Clementina Oddenino";
        foaf:age 66;
        &hellip;
    ].

[] a foaf:Person 
    &hellip;</pre>
            <pre>public class FOAF {

    public static final Node Person=
        new Node(URI.create("http://xmlns.com/foaf/0.1/Person"));

    public static final Node name=
        new Node(URI.create("http://xmlns.com/foaf/0.1/name"));

    public static final Node knows=
        new Node(URI.create("http://xmlns.com/foaf/0.1/knows"));
    &hellip;
}</pre>
            <p>Examples in the <a href="#_Queries">Queries</a> and <a href="#_Datalog">Datalog</a> sections assumes a
                graph describing a social network using <a href="http://en.wikipedia.org/wiki/FOAF_(software)">FOAF</a>
                and <a href="http://en.wikipedia.org/wiki/Dublin_Core">DC</a> vocabularies and a utility class defining
                constants for FOAF terms as URI reference nodes. Framework utility classes defining constants for RDF and
                XSD terms and datatypes are also referenced.</p><h1><a class="bookmark" name="Graphs" href="#@top"></a>Graphs
            </h1><p><a href="api/index.html?net/oroboro/Graph.html">Graphs</a> contain collections of RDF statements,
                described as directed labeled <a href="api/index.html?net/oroboro/Edge.html">edges</a> connecting
                <a href="api/index.html?net/oroboro/Node.html">nodes</a>. Graphs are <em>readable</em> if they support
                edge retrieval operations, <em>writable</em> if the support edge insertion and possibly edge removal
                operations.</p>
            <pre>Graph graph=new Store();</pre>
            <p>Creates a <a href="api/index.html?net/oroboro/Store.html">store</a>, a heap-based, indexed graph
                implementation: custom implementations may be used to expose data stored into relational bases or other
                external repositories.</p><h2><a class="bookmark" name="Nodes" href="#@top"></a>Nodes</h2><h3>
                <a class="bookmark" name="Creating nodes" href="#@top"></a>Creating nodes</h3>
            <pre>new Node()</pre>
            <p>Creates a blank node.</p>
            <pre>new Node(URI.create("http://example.org/"))</pre>
            <p>Creates a URI reference.</p>
            <pre>new Node("text")</pre>
            <p>Creates a plain literal with no language tag.</p>
            <pre>new Node("text", "en")</pre>
            <p>Creates a plain literal with a language tag.</p>
            <pre>new Node("123", URI.create("http://www.w3.org/2001/XMLSchema#integer"))</pre>
            <p>Creates a typed literal with a datatype identified by a URI.</p>
            <pre>new Node("123", XSD._integer)</pre>
            <p>Creates a typed literal with a <a href="api/index.html?net/oroboro/ns/package-summary.html">well-known</a>
                datatype.</p>
            <pre>new Node(123)
new Node(new Date(), XSD._dateTime)</pre>
            <p>Creates a typed literal from a Java object. The datatype argument may be omitted for booleans and
                numbers.</p><p>Nodes are immutable value-objects: after initialization they are never altered and compare
                equal if they describe the same RDF term, that is if they have the same <em>lexical form</em> and the
                same <em>datatype</em> URI.</p><h3>
                <a class="bookmark" name="Accessing lexical forms and datatypes" href="#@top"></a>Accessing lexical forms
                and datatypes</h3>
            <pre>new Node("text").text() // .equals("text")
new Node(123).text() // .equals("123")</pre>
            <p>Retrieves the <em>lexical form</em> of a node.</p>
            <pre>new Node("text", "en").tag() // .equals("en")
new Node("text").tag() // == null (no language tag!)</pre>
            <p>Retrieves the <em>language tag</em> of a node or <code>null</code> if the node is not a plain literal with
                a tag.</p>
            <pre>new Node(123).type().uri()
    // .equals(URI.create("http://www.w3.org/2001/XMLSchema#int"))</pre>
            <p>Retrieves the <em>datatype</em> URI of a node. Beside access to the datatype URI, the
                <a href="#_Datatypes_4">datatype</a> object retrieved by <code>type()</code>, provides methods for
                mapping between lexical and value spaces defined by the datatype. The framework natively supports core
                XSD datatypes, but <a href="#_Plugging">custom datatypes</a> may be defined and plugged into the datatype
                registry of the framework.</p><p>Every node has a lexical form and a datatype: Oroboro generalizes the
                standard RDF abstract model to blank nodes, URI references and plain literals by treating them as typed
                literals with an implementation-specific internal datatype. Blank nodes and URI references have a lexical
                form corresponding respectively to the internal node identifier and to the referenced URI.</p><h3>
                <a class="bookmark" name="Testing datatypes" href="#@top"></a>Testing datatypes</h3>
            <pre>new Node().isBlank() // == true</pre>
            <p>Tests blank nodes.</p>
            <pre>new Node(URI.create("http://example.org/")).isReference() // == true</pre>
            <p>Tests URI references nodes.</p>
            <pre>new Node("text").isLiteral() // == true
new Node("text").isPlain() // == true
new Node("text").isSimple() // == true</pre>
            <p>Tests plain literals with no language tag.</p>
            <pre>new Node("text").isLiteral() // == true
new Node("text").isPlain() // == true
new Node("text", "en").isTagged() // == true
new Node("text", "en").isTagged("en") // == true</pre>
            <p>Tests plain literals with a language tag.</p>
            <pre>new Node(123).isLiteral() // == true
new Node(123).isTyped() // == true
new Node(123).isTyped(XSD._int) // == true</pre>
            <p>Tests typed literals.</p>
            <pre>new Node(123).isNumeric() // == true
new Node(123).isInt() // == true</pre>
            <p>Typed literals with a boolean or numeric datatype may be tested with dedicate methods.</p><h3>
                <a class="bookmark" name="Accessing values" href="#@top"></a>Accessing values</h3>
            <pre>Object value=node.value();</pre>
            <p>Retrieves the <em>value</em> of a node or <code>null</code> if its lexical form doesn't actually belong to
                the lexical space of its stated datatype.</p><p>Every node has a (possibly
                <code>null</code><code>)</code> value, represented by a Java object: URIs represent URI references;
                strings represent plain literals; booleans and numbers represent core XSD datatypes. Other associations
                may be defined by extended XSD or custom datatypes.</p><h3>
                <a class="bookmark" name="Accessing typed values" href="#@top"></a>Accessing typed values</h3><p>URI
                references and typed literals with an XSD datatype may return a strictly typed value.</p>
            <pre>URI value=node.uri();</pre>
            <p>Retrieves the <em>URI</em> of a node or <code>null</code> if the node isn't a URI reference or its lexical
                form doesn't actually represent an URI.</p>
            <pre>Date value=node.value(XSD._date);</pre>
            <p>Retrieves the <em>typed value</em> of a node or <code>null</code> if its datatype isn't derived from the
                target datatype or its lexical form is illegal.</p>
            <pre>Boolean value=node._boolean();</pre>
            <p>The value of typed literals with a boolean or numeric datatype may be accessed with dedicate methods.</p>
            <h2><a class="bookmark" name="Edges" href="#@top"></a>Edges</h2><h3>
                <a class="bookmark" name="Creating edges" href="#@top"></a>Creating edges</h3>
            <pre>new Edge(new Node("subject"), new Node("predicate"), new Node("object"));</pre>
            <p>Creates an edge referencing the specified nodes respectively as <em>subject</em>, <em>predicate</em> and
                <em>object.</em><em> </em>Edges are immutable value-objects: after initialization they are never altered
                and compare equal if they describe the same RDF statement, that is if the reference equal nodes in the
                same roles.</p><p>Edge nodes aren't constrained by their role: Oroboro generalizes the standard RDF
                abstract model to edges with literal subjects and blank or literal predicates. Such edges are ignored
                when serializing the graph to a format that doesn't support them.</p><h3>
                <a class="bookmark" name="Inserting edges into graphs" href="#@top"></a>Inserting edges into graphs</h3>
            <pre>graph.insert(new Edge(new Node(&hellip;), new Node(&hellip;), new Node(&hellip;)));</pre>
            <p>Inserts an edge into a graph.</p><h3>
                <a class="bookmark" name="Removing edges from graphs" href="#@top"></a>Removing edges from graphs</h3>
            <pre>graph.remove(new Edge(new Node(&hellip;), new Node(&hellip;), new Node(&hellip;)));</pre>
            <p>Removes an edge from a graph.</p><h2>
                <a class="bookmark" name="Patterns" href="#@top"></a><a name="_Patterns"></a>Patterns</h2><p>Edges
                referencing <code>null</code> nodes represent <em>edge </em><em>pattern</em><em>s</em>.</p>
            <pre>new Edge(new Node("subject"), null, null);</pre>
            <p>Creates an edge pattern matching any edge with the specified subject.</p><h3>
                <a class="bookmark" name="Iterating over graph edges matching a pattern" href="#@top"></a>Iterating over
                graph edges matching a pattern</h3>
            <pre>for (Edge e : graph.lookup(new Edge(null, new Node("predicate"), null)) {
    &hellip;
}</pre>
            <p>Iterates over all of the edges in a graph matching the specified predicate.</p><h3>
                <a class="bookmark" name="Removing graph edges matching a pattern" href="#@top"></a>Removing graph edges
                matching a pattern</h3>
            <pre>graph.remove(new Edge(null, null, new Node("object"));</pre>
            <p>Removes from a graph all of the edges matching the specified object.</p><h1>
                <a class="bookmark" name="Codecs" href="#@top"></a>Codecs</h1><h2>
                <a class="bookmark" name="Endpoints" href="#@top"></a>Endpoints</h2><p>All I/O operations in the
                framework are performed on <a href="api/index.html?net/oroboro/io/Origin.html"><em>origin</em></a> and
                <a href="api/index.html?net/oroboro/io/Target.html"><em>target</em></a> data endpoints. Endpoints are
                specified with a suitable combination of defining attributes (URI, URL, input or output stream, reader,
                writer, character encoding, &hellip;) and provide uniform access to the values of the specified
                attributes or to equivalent objects derived from the ones originally supplied.</p><h3>
                <a class="bookmark" name="Defining input origins" href="#@top"></a>Defining input origins</h3>
            <pre>new Origin(new URI("http://example.org/data/sample.rdf"))
new Origin(new URL("file:dataset.ttl"));
new Origin(new FileInputStream("dataset.ttl"))
new Origin(new StringReader("&lt;http://example.org/data&gt; a &hellip;"))</pre>
            <p>Creates input origins wrapping data sources (URI, URL, input stream, reader).</p>
            <pre>new Origin(new URL("file:dataset.ttl"), "ISO-8859-1")</pre>
            <p>Specifies a character encoding for reading text from a data source.</p>
            <pre>new Origin(URI.create(("http://example.org/data/"), new URL("file:data.ttl"))</pre>
            <p>Specifies a base for resolving relative URI references while reading from a data source.</p><h3>
                <a class="bookmark" name="Defining output targets" href="#@top"></a>Defining output targets</h3>
            <pre>new Target(new URI("http://example.org/data/sample.rdf"))
new Target(new URL("file:dataset.ttl"));
new Target(new FileOutputStream("dataset.ttl"))
new Target(new StringWriter())</pre>
            <p>Creates output targets wrapping data sinks (URI, URL, output stream, writer).</p>
            <pre>new Target(new URL("file:dataset.ttl"), "ISO-8859-1")</pre>
            <p>Specifies a character encoding for writing text to a data sink.</p>
            <pre>new Target(URI.create(("http://example.org/data/"), new URL("file:data.ttl"))</pre>
            <p>Specifies a base for relativizing URI references while writing to a data sink.</p><h3>
                <a class="bookmark" name="Accessing endpoints" href="#@top"></a>Accessing endpoints</h3>
            <pre>new Origin(new URL("file:data.ttl")).reader()</pre>
            <p>Creates a reader for reading from an input origin defined by a URL, assuming UTF-8 as encoding.</p>
            <pre>new Target(new FileInputStream("dataset.ttl"), "ISO-8859-1").writer()</pre>
            <p>Creates a writer for writing to an output target defined by an input stream and a character encoding.</p>
            <h3><a class="bookmark" name="Accessing Java resources" href="#@top"></a>Accessing Java resources</h3><p>
                Input origins may refer to local resources loadable from the Java classpath.</p>
            <pre>new Origin(org.example.Data.class, "converter.xsl")</pre>
            <p>Creates an input source for loading an XSLT stylesheet from a resource of a Java class.</p>
            <pre>new Origin(URI.create("java:org.example#converter.xsl"))
new Origin(URI.create("java:/org/example/converter.xsl"))</pre>
            <p>Creates an input source for loading an XSLT stylesheet from a resource identified using the special <code>java:</code>
                URI scheme. This scheme may be used to identify Java resources wherever the I/O framework accepts a URI:
                if the URI includes a fragment, the scheme-specific part is interpreted as a fully qualified package name
                and the fragment as the name of a resource to be loaded from the package by the default class loader;
                otherwise the scheme-specific part is interpreted as the absolute path of a resource.</p><h2>
                <a class="bookmark" name="Decoders" href="#@top"></a>Decoders</h2><p>
                <a href="api/index.html?net/oroboro/io/Decoder.html">Decoders</a> read serialized RDF statements from an
                input origin and insert them as edges into a writable graph. The framework supports decoding from
                <a href="api/index.html?net/oroboro/io/txt/NTDecoder.html">N-Triples</a>,
                <a href="api/index.html?net/oroboro/io/txt/TTLDecoder.html">Turtle</a> and
                <a href="api/index.html?net/oroboro/io/xml/RDFDecoder.html">RDF/XML</a> serialization formats.</p>
            <pre>Graph graph=new TTLDecoder()
    .decode(new Origin(URI.create("http://example.org/data.ttl"));</pre>
            <p>Decodes a Turtle input origin to a new graph.</p>
            <pre>Graph graph=new Store();

new RDFDecoder()
    .decode(new Origin(new FileInputStream("data.rdf")), graph);</pre>
            <p>Decodes an RDF/XML input origin to an existing graph.</p><h2>
                <a class="bookmark" name="Encoders" href="#@top"></a>Encoders</h2><p>
                <a href="api/index.html?net/oroboro/io/Encoder.html">Encoders</a> iterates over edges in a readable graph
                and write them as serialized RDF statements to an output target. The framework supports encoding to
                <a href="api/index.html?net/oroboro/io/txt/NTEncoder.html">N-Triples</a>,
                <a href="api/index.html?net/oroboro/io/txt/TTLEncoder.html">Turtle</a> and
                <a href="api/index.html?net/oroboro/io/xml/RDFEncoder.html">RDF/XML</a> serialization formats.</p>
            <pre>Graph graph=new Store();

new TTLEncoder()
    .encode(new Target(new FileOutputStream("data.ttl")), graph);</pre>
            <p>Encodes a graph to a Turtle output target.</p><h2>
                <a class="bookmark" name="Guessing" href="#@top"></a><a name="_Guessing"></a><a name="_Guessing_1"></a>Guessing
            </h2><p>Beside format-specific codecs, the framework provides generic
                <a href="api/index.html?net/oroboro/io/any/package-summary.html">format-guessing</a> ones: guessing is
                performed on the basis of the filename extension of the URL of the specified endpoint, if one is known,
                falling back to a default, otherwise.</p>
            <pre>new AnyDecoder()
    .decode(new Origin(new FileInputStream("data.ttl")));</pre>
            <p>Decodes a Turtle input origin to a new graph. </p>
            <pre>Graph graph=new Store();

new AnyEncoder()
    .encode(new Target(System.out), graph);</pre>
            <p>Encodes a graph to the system output, falling back to the Turtle serialization, as the output target has
                no known URL.</p>
            <pre>new AnyDecoder().fallbacks(new TTLDecoder(), new RDFDecoder());
new AnyEncoder().fallback(new RDFEncoder());</pre>
            <p>Fallback codecs may be configured as required. Format-guessing decoders accept an array of options, which
                are tried out on input origins in the specified order.</p><h2>
                <a class="bookmark" name="Catalogs" href="#@top"></a>Catalogs</h2><p>
                <a href="api/index.html?net/oroboro/io/Catalog.html">Catalogs</a> provide a context for URI-related
                operations, such as relativization, resolution, qualification, compaction and expansion.</p><h3>
                <a class="bookmark" name="Controlling namespace prefixes" href="#@top"></a>Controlling namespace prefixes
            </h3>
            <pre>Graph graph=new Store();

Catalog catalog=new Catalog();
catalog.prefix("foaf", URI.create("http://xmlns.com/foaf/0.1/"));

new TTLEncoder().encode(catalog,
    new Target(new FileOutputStream("data.ttl")), graph);</pre>
            <p>Encodes a graph to a Turtle output target expressing URIs as qualified names with the specified prefix,
                wherever possible.</p><h3>
                <a class="bookmark" name="Reusing prefixes declared by input origins" href="#@top"></a>Reusing prefixes
                declared by input origins</h3>
            <pre>Graph graph=new Store();
Catalog catalog=new Catalog();

new TTLDecoder().decode(catalog,
    new Origin(new FileInputStream("one.ttl")), graph);
new TTLDecoder().decode(catalog,
    new Origin(new FileInputStream("two.ttl")), graph);

new TTLEncoder().encode(catalog,
    new Target(new FileOutputStream("data.ttl")), graph);</pre>
            <p>Decodes two Turtle input origins into graph and encodes it to an output target, sharing the reference
                catalog among codecs. Decoders collect namespace prefixes declared by the input origins into the shared
                catalog, enabling the encoder to use them for qualifying URIs in the output target.</p><h2>
                <a class="bookmark" name="Morphing" href="#@top"></a><a name="_Morphers"></a>Morphing</h2><p>
                <a href="api/index.html?net/oroboro/io/Morpher.html">Morphers</a> provide a simplified,
                <a href="http://en.wikipedia.org/wiki/Fluent_interface">fluent</a> API for the implementation of graph
                processing pipelines. They manage a working graph and a shared reference catalog for URI management. Many
                common sequences of graph operations may be concisely expressed as chained invocations of morpher methods
                acting on the working graph and the shared catalog.</p>
            <pre>new Morpher()
    .decode(new Origin(new FileInputStream("input.rdf")))
    .encode(new Target(new FileOutputStream("output.ttl")));</pre>
            <p>Transcodes an RDF/XML input origin to a Turtle output target. Serialization formats are
                <a href="#_Guessing">guessed</a> as described above.</p>
            <pre>new Morpher()
    .decode(new Origin(new FileInputStream("one.nt")))
    .decode(new Origin(new FileInputStream("two.rdf")))
    .encode(new Target(new FileOutputStream("data.ttl")));</pre>
            <p>Decodes two input origins merging them into the working graph and encodes it to an output target, sharing
                the reference catalog among codecs. Namespace prefixes collected from input origins are used to qualify
                names in the output target.</p><h1>
                <a class="bookmark" name="XML/XSLT" href="#@top"></a><acronym>XML/</acronym><acronym>XSLT</acronym></h1>
            <h2><a class="bookmark" name="Transformers" href="#@top"></a>Transformers</h2><p>
                <a href="api/index.html?net/oroboro/io/Xformer.html">Transformers</a> provide a simplified,
                <a href="http://en.wikipedia.org/wiki/Fluent_interface">fluent</a> API for the implementation of
                XML/XSLT-based processing pipelines, integrated with the
                <a href="http://download.oracle.com/javase/6/docs/api/javax/xml/transform/package-summary.html?is-external=true">Java
                    XML Transform</a> framework. They manage a DOM-based working XML tree and a shared reference catalog
                for URI management. Many common sequences of XML/XSLT operations may be concisely expressed as chained
                invocations of transformer methods acting on the working XML tree and the shared catalog.</p>
            <pre>new Xformer()
    .parse(new Origin(new FileInputStream("input.xml")))
    .apply(new Origin(org.exmple.Data.class, "convert.xsl"))
    .write(new Target(new FileOutputStream("output.rdf")));</pre>
            <p>Parses an XML input origin, converts it into an RDF/XML document using an XSLT transform loaded from a
                Java resource and writes the result to an XML output target.</p><h2>
                <a class="bookmark" name="Transcribers" href="#@top"></a>Transcribers</h2><p>
                <a href="api/index.html?net/oroboro/io/Xscriber.html">Transcribers</a> provides support for the
                implementation of SAX-based parsers. Possible usages include the integration of external data sources: in
                this scenario, external data encoded in application-specific formats is presented to XML processing tools
                as a stream of SAX events by means of custom transcribers. The framework includes standard transcribers
                for the <a href="api/index.html?net/oroboro/io/sax/CSVReader.html">CSV</a> and
                <a href="api/index.html?net/oroboro/io/sax/JSONReader.html">JSON</a> formats.</p>
            <pre>new Xformer()
    .parse(new Origin(new FileInputStream("data.csv")), new CSVReader())
    .apply(new Origin(org.example.Data.class, "convert.xsl"))
    .write(new Target(new FileOutputStream("data.rdf")));</pre>
            <p>Parses a comma-separated input origin with the specific SAX parser, transforms it into an RDF/XML document
                using an XSLT transform loaded from a Java resource and writes the result to an XML output target.</p>
            <h2><a class="bookmark" name="Morphing" href="#@top"></a>Morphing</h2><p>
                <a href="api/index.html?net/oroboro/io/Morpher.html">Morphers</a> may directly decode and encode XML
                trees managed by transformers and Java XML Transform sources and results.</p>
            <pre>new Morpher()
    .decode(new Xformer()
        .parse(new Origin(new FileInputStream("data.csv")), new CSVReader())
        .apply(new Origin(org.example.Data.class, "convert.xsl")))
    .encode(new Target(new FileOutputStream("output.ttl")));</pre>
            <p>Parses a comma-separated input origin with a specific SAX transcriber, transforms it into an RDF/XML
                document using an XSLT transform loaded from a Java resource and transcodes it to a Turtle output
                target.</p><h2><a class="bookmark" name="Integration" href="#@top"></a>Integration</h2><h3>
                <a class="bookmark" name="Integrating with Java XML Transforms" href="#@top"></a><acronym>Integrating
                with </acronym><acronym>Java XML Transforms</acronym></h3><p>Transformers may act either as
                <em>sources</em> or <em>results</em> for tools based on the Java XML Transform framework.</p>
            <pre>Templates templates=&hellip;;
Result result=&hellip;;

Xformer xformer=new Xformer();

templates.newTransformer().transform(xformer.source(), result);</pre>
            <p>Transforms the working XML tree of a transformer into an XML result using an external XSLT tempate.</p>
            <pre>Templates templates=&hellip;;
Source source=&hellip;;

Xformer xformer=new Xformer();

templates.newTransformer().transform(source, xformer.result());</pre>
            <p>Transforms an XML source with an extenal XSLT template and stores the result as the working XML tree of a
                transformer.</p><h3>
                <a class="bookmark" name="Integrating with SAX-based tools" href="#@top"></a><acronym>Integrating </acronym>with
                <acronym>SAX-based tools</acronym></h3><p>The Java XML Transform interface enables transformers to
                interact with SAX-based tools as well.</p>
            <pre>InputSource source=&hellip;;

new Xformer()
    .parse(new SAXSource(source))
    .write(new Target(new FileOutputStream("output.rdf")));</pre>
            <p>Parses a SAX input source and writes the result to an XML output target.</p>
            <pre>ContentHandler handler=&hellip;;

new Xformer()
    .parse(new Origin(new FileInputStream("input.xml")))
    .write(new SAXResult(handler));</pre>
            <p>Parses an XML input origin an writes it as a stream of SAX events to a content handler.</p><h3>
                <a class="bookmark" name="Integrating with DOM-based tools" href="#@top"></a><acronym>Integrating </acronym>with
                <acronym>DOM-based tools</acronym></h3><p>The Java XML Transform interface enables transformers to
                interact with DOM-based tools as well.</p>
            <pre>Node node=&hellip;;

new Xformer()
    .parse(new DOMSource(node))
    .write(new Target(new FileOutputStream("output.rdf")));</pre>
            <p>Writes a DOM tree to an XML output target</p>
            <pre>Node node=new Xformer()
    .parse(new Origin(new FileInputStream("input.xml")))
    .result().getNode();</pre>
            <p>Parses an XML input origin and returns it as a DOM tree.</p><h1>
                <a class="bookmark" name="Queries" href="#@top"></a><a name="_Linked_Data"></a><a name="_Queries"></a>Queries
            </h1><p><a href="api/index.html?net/oroboro/Query.html">Queries</a> support linked data navigation among
                related sets of nodes in graphs. They reference a graph and an ordered collection of nodes, used as a
                starting point for the creation of related collections. Derived queries may be used as a starting point
                for further action, tested for specific conditions, iterated or converted into actual nodes collections.
            </p><h2><a class="bookmark" name="Navigation" href="#@top"></a><a name="_Navigation"></a>Navigation</h2><h3>
                <a class="bookmark" name="Creating and initializing queries" href="#@top"></a>Creating and initializing
                queries</h3>
            <pre>new Query(graph).insert(FOAF.Person);</pre>
            <p>Creates a linked data query over a graph and inserts a starting node in the nodes collection.</p><p>Nodes
                are immutable value-objects: after initialization they are never altered and compare equal if they
                contain equal nodes collections, regardless of the referenced graph. In the previous example the <code>insert</code><code> </code>method
                doesn't actually modify the nodes collection of the initial empty query: it rather creates and returns a
                derived query object containing all of the nodes of the starting query plus the specified one. All of the
                navigation methods described below return derived query objects, leaving the original query available as
                a starting point for further action.</p><h3><a class="bookmark" name="Following links" href="#@top"></a>Following
                links</h3>
            <pre>new Query(graph).insert(FOAF.name).targets();</pre>
            <p>Creates a query containing all of the object nodes in the graph that are the <em>name</em> of someone: for
                each edge in the query graph referencing the <code>FOAF.name</code> node in the predicate role, the
                object node is added to the derived query. If the query graph contains the following edges:</p>
            <pre>_:a rdf:type foaf:Person.
_:a foaf:name "Libertino Faussone".
_:a foaf:nick "Tino".
_:a foaf:knows _:b.
_:a foaf:knows _:c.
_:b foaf:name "Primo Levi".
_:b foaf:age 59.
_:c foaf:name "Clementina Oddenino".</pre>
            <p>the nodes collection of the derived query will contain <code>"</code>Libertino <code>Faussone"</code>,
                <code>"Primo Levi" </code>and<code> </code><code>"Clementina </code>Oddenino<code>"</code><code>.</code>
            </p><h3><a class="bookmark" name="Following links from multiple query nodes" href="#@top"></a>Following links
                from multiple query nodes</h3><p>Queries contains <em>collections</em> of nodes: the derived collection
                returned by navigation methods is actually the union of the collections identified by following links
                from nodes in the starting one.</p>
            <pre>new Query(graph).insert(FOAF.name, FOAF.nick).targets();</pre>
            <p>If we add a second predicate to the initial query in the previous example, the nodes collection of the
                derived query will contain <code>"</code>Libertino <code>Faussone"</code>, <code>"Primo
                    Levi", </code><code>"Clementina </code>Oddenino<code>"</code> <strong>and</strong>
                <code>"</code><code>Tino</code><code>"</code>, that is all of the object nodes in the graph that are
                <strong>either</strong> the <em>name</em> <strong>or</strong> the <em>nickname</em> of someone.</p><h3>
                <a class="bookmark" name="Navigation patterns" href="#@top"></a>Navigation patterns</h3><p>All of the
                navigation methods follow the same pattern: for each edge in the query graph referencing a query node in
                the <em>starting</em> role, the node referenced in the <em>derived</em> role is added to the derived
                query. The following combinations are thus possible:</p><p>
                <img style="width: 8.831791666666666cm; height: 2.54cm;" src="data:image/png;base64,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%0A5CzsfGap3FK0UFTcGwpLKmXditmS52Hu3bBCZs28M0K2UIpLzpRVKjfjYhnpyLfKi0vnyXULHa5H%0AQ0BW1z4ltxXkSuvWR2TYJb+U8tU/kzn/+/OSp2eDDEQgRRDABv5n7CtvoDtjQJNA1yC/G7E6De+h%0APKGTgMsvv3z44MGDf4M6YU4C8rpvXQV6AMnvaz6VQ9q8ozBz5ky9UbkxFpgA/KK8vLwZscrJJwKZ%0AhEDTnlfkkbu/LCcPHw8nYSXc52lylv7jfes+ec3u+nASAsWLZXXVGikvhdOAUHvvI7Kl1UnKzifv%0AlvHGSSiE3BrIVywuduVWzpFvrdA10Q0HNvxI8o2TUFhUBp1rZfXyUhTWyqqV1Y5QyZRxcEA6ZMOP%0AikJOQsniCvgqa6SsWP37arm98N9kJ+6fss/Mx+1arSy8fboMP3mA3L30SdnZlPI3Vi4Y/OwXCKgz%0AgLAb9DsMeClIHYUrQQux31wL8vrRYHcNgwYNuhVyZ3UtCXG+jfKTQrkUTaTNiQIu1gQA2i2MAwcO%0AnACBF7sVYiERSFsEOmTP6y/IL5f8UJZUud5AYXGZlN89V66aNNo5JWjbVSv2DKFsTa08eFOBO9pZ%0AE2XPsipZWXihnHUyWM2vyLyv6S9Ji5SsrpUVt1m5WXLV+LPkPJRVPfGqNM+dJLltW2XhzHsd2eKK%0AzfLbufZk/1q5euI5Mnz6XU7ZpIKR0rbndzLzXnUcArJm9wty0xj3qGDWrJkyuvUMubNqpfz+7Ydk%0A/qRZsiHYIltffEoeXjhHli38GgiHIKXLpey7d8jUWI8+nJb4QQT6FgHsP0fQop4wvIF96EzEesrw%0ADaRbEKtH/RZkupxmmz0JxTHDUDxSPxelu2JKpEBB2jgKwGp/PLyOHTvWRQYX8jLUuzJeXZYTgb5C%0A4O233x4zfvz4xJvDewFb1/0OG+qdssr1D7ChVmBDvbnLhtqw/U+u3pIqWWydBOW0fSgfa1x7WD9l%0AJzZs5xygeLUst06CU4Kz1i/dIUUCR2HYYMf52Pvcb91HC0WV8mjISXCF86YERM8gVqHGZ/Oz5bnv%0Al7sFRbfIxKwG2bmz3cnjsaF8+kI88q2qlg8/0CONHIcmXTtbfnttsTyw9QVZsRgO0LK7pAqkDtCP%0A4ABdbxwgV2n8z/3793961KhRP4gvSQki0C0Ch1B6SrcSbuFnEE0DfR3U5U4WzsO+ODe4xz744IMD%0A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">
            </p>
            <table cellspacing="0" style="width: 100%;margin-left: auto; margin-right: auto;">
                <tr style="text-align: center;">
                    <td style="padding-left: 3pt; padding-right: 3pt; width: 0%;"><p style="text-align: right;"><code>query.objects()</code>
                    </p></td>
                    <td style="padding-left: 3pt; padding-right: 3pt; width: 0%;"><p style="text-align: justify;">
                        navigates from subjects to objects;</p></td>
                </tr>
                <tr style="text-align: center;">
                    <td style="padding-left: 3pt; padding-right: 3pt; width: 0%;"><p style="text-align: right;"><code>query.subjects()</code>
                    </p></td>
                    <td style="padding-left: 3pt; padding-right: 3pt; width: 0%;"><p style="text-align: justify;">
                        navigates from objects to subjects;</p></td>
                </tr>
                <tr style="text-align: center;">
                    <td style="padding-left: 3pt; padding-right: 3pt; width: 0%;"><p style="text-align: right;"><code>query.traits()</code>
                    </p></td>
                    <td style="padding-left: 3pt; padding-right: 3pt; width: 0%;"><p style="text-align: justify;">
                        navigates from subjects to predicates;</p></td>
                </tr>
                <tr style="text-align: center;">
                    <td style="padding-left: 3pt; padding-right: 3pt; width: 0%;"><p style="text-align: right;"><code>query.roles()</code>
                    </p></td>
                    <td style="padding-left: 3pt; padding-right: 3pt; width: 0%;"><p style="text-align: justify;">
                        navigates from objects to predicates;</p></td>
                </tr>
                <tr style="text-align: center;">
                    <td style="padding-left: 3pt; padding-right: 3pt; width: 0%;"><p style="text-align: right;"><code>query.targets()</code>
                    </p></td>
                    <td style="padding-left: 3pt; padding-right: 3pt; width: 0%;"><p style="text-align: justify;">
                        navigates from predicates to objects;</p></td>
                </tr>
                <tr style="text-align: center;">
                    <td style="padding-left: 3pt; padding-right: 3pt; width: 0%;"><p style="text-align: right;"><code>query.sources()</code>
                    </p></td>
                    <td style="padding-left: 3pt; padding-right: 3pt; width: 0%;"><p style="text-align: justify;">
                        navigates from predicates to subjects.</p></td>
                </tr>
            </table>
            <h3><a class="bookmark" name="Navigating with constraints" href="#@top"></a>Navigating with constraints</h3>
            <p>All of the navigation methods may be <em>constrained</em> to consider only edges referencing a specific
                node in the third, so far disregarded, role.</p>
            <pre>new Query(graph).insert(FOAF.Person).subjects(RDF.type)</pre>
            <p>Returns all of the nodes in the graph that are <em>persons</em>, that is that are subjects with <code>FOAF.Person</code>
                as object for the <code>RDF.type</code> predicate.</p><h3>
                <a class="bookmark" name="Navigating with constraint filters" href="#@top"></a>Navigating with constraint
                filters</h3><p>Complex constraints may be expressed using
                <a href="api/index.html?net/oroboro/Filter.html">filters</a>.</p>
            <pre>new Query(graph).insert(FOAF.age).sources(new Filter() {
    public boolean filter(final Query query) {
        return query.node()._integer().intValue() &gt; 50;
    }
})</pre>
            <p>Returns all of the nodes in the graph whose <em>age</em> is greater than 50, that is whose object for the
                <code>FOAF.</code><code>age</code> predicate evaluates to <code>true</code> when processed by the
                specified filter.</p><h3><a class="bookmark" name="Multiple hops" href="#@top"></a>Multiple hops</h3><p>
                Navigation methods may be chained to follow multiple forward and backward links.</p>
            <pre>new Query(graph).insert(new Node("Tino Faussone"))
    .subjects(FOAF.name).objects(FOAF.knows).objects(FOAF.names)</pre>
            <p>Returns the names of the people known by the subject whose name is <code>"Tino Faussone"</code>.</p><h3>
                <a class="bookmark" name="Complex structures" href="#@top"></a>Complex structures</h3><p>Beside
                node-to-node links, queries understand some complex structures, such as lists.</p>
            <pre>&nbsp;"list" rdf:first "one"; rdf:rest [
    rdf:first "two"; rdf:rest [
        rdf:first "three"; rdf:rest rdf:nil]].</pre>
            <pre>&nbsp;new Query(graph).insert(new Node("list")).items()</pre>
            <p>Returns <code>"one"</code>, <code>"two"</code>, <code>"three"</code>, that is the items of the specified
                list in the listed context .</p><h2><a class="bookmark" name="Filtering" href="#@top"></a>Filtering</h2>
            <p>Queries may be derived by <em>filtering</em> the nodes collection of a starting query.</p>
            <pre>new Query(graph).insert(FOAF.Person).subjects(RDF.type)
    .filter(new Filter() {
        public boolean filter(final Query query) {
            return query.objects(FOAF.knows).size() &gt;= 2;
        }
    })</pre>
            <p>Returns all of the nodes of the graph that are <em>persons</em> and know at least two people.</p><h2>
                <a class="bookmark" name="Ordering" href="#@top"></a>Ordering</h2><p>Queries contains <em>ordered</em>
                collections of nodes, which may be sorted according to a user-defined criterion.</p>
            <pre>new Query(graph).insert(FOAF.name).order(new Comparator&lt;Node&gt;() {
    public int compare(Node x, Node y) {
        return x.text().compareTo(y.text());
    }
}).targets()</pre>
            <p>Returns all of the object nodes in the graph that are the <em>name</em> of someone, in alphabetical order.
                Note that custom ordering is inherited by derived queries.</p><h2>
                <a class="bookmark" name="Results" href="#@top"></a>Results</h2><p>Query results are contained in the
                derived query obtained at the end of a sequence of navigation and filtering methods. The nodes in the
                derived query may be iterated and retrieved in a couple of different ways.</p><h3>
                <a class="bookmark" name="&nbsp;Retrieving nodes collections" href="#@top"></a>&nbsp;Retrieving nodes
                collections</h3>
            <pre>new Query(graph).<em>&lt;navigate&gt;</em>.set()</pre>
            <p>Returns the nodes collection of a query as a node set.</p>
            <pre>new Query(graph).<em>&lt;navigate&gt;</em>.list()</pre>
            <p>Returns the nodes collection of a query as an ordered node list.</p><h3>
                <a class="bookmark" name="&nbsp;Retrieving nodes" href="#@top"></a>&nbsp;Retrieving nodes</h3>
            <pre>new Query(graph).<em>&lt;navigate&gt;</em>.node()</pre>
            <p>Returns the singleton node of a query or <code>null</code> if the query contains no or multiple nodes.</p>
            <h3><a class="bookmark" name="Splitting queries" href="#@top"></a>Splitting queries</h3>
            <pre>for (final Query query : new Query(graph).<em>&lt;navigate&gt;</em>) {
    &hellip;
}</pre>
            <p>Iterates over a sequence of queries, each containing a single node drawn from the nodes collection of the
                starting query according to its ordering.</p><h1>
                <a class="bookmark" name="Datalog" href="#@top"></a><a name="_Datalog"></a>Datalog</h1><p class="note">
                Work in progress. Details may change in future releases.</p><p>The framework provides an integrated
                <a href="http://en.wikipedia.org/wiki/Datalog">Datalog</a>-like language that support querying,
                inferencing and updating over RDF graphs. Queries, inference and update rules are described by logical
                <em>programs</em> executed by a dedicated <a href="api/index.html?net/oroboro/Engine.html">engine</a>.
            </p><h2><a class="bookmark" name="Programs" href="#@top"></a>Programs</h2>
            <pre># A Datalog program

prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

lookup ? foaf:name ?name.</pre>
            <p>While supporting standard Datalog semantics, programs are written in a custom Turtle-based
                <a href="grammar.html">language</a>, better suited to deal with graph patterns than the usual Prolog
                notation. Queries and rules are defined as <em>clauses</em> built from <em>patterns</em>; <em>d</em><em>irectives</em>
                control namespace bindings and URI resolution. Single line comments introduced by hash characters ('#')
                and whitespace are generally ignored. Keywords are case insensitive.</p><h3>
                <a class="bookmark" name="Parsing and assembling programs" href="#@top"></a>Parsing and assembling
                programs</h3>
            <pre>Graph query=new DLDecoder()
    .decode(new Origin(new URL("file:program.dl")));</pre>
            <p>Datalog programs are parsed either by dedicated or format-guessing decoders, using the <code>'.dl'</code>
                filename extension in the latter case.</p>
            <pre>@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt;.
@prefix ode: &lt;http://oroboro.net/schema/datalog#&gt;.

[] a ode:Lookup ;
    ode:target [
            a ode:Atom ;
            ode:subject []
            ode:predicate foaf:name ;
            ode:object [ode:name "name"] ;
        ] .</pre>
            <p>The dedicated decoder translates Datalog programs into a graph describing program clauses using a
                semantically equivalent RDF <a href="vocabulary.html">vocabulary</a>: if required, Datalog programs might
                be built programmatically, assembling RDF descriptions directly through the model API.</p><h3>
                <a class="bookmark" name="Compiling and executing programs" href="#@top"></a>Compiling and executing
                programs</h3>
            <pre>Graph data=new AnyDecoder()
    .decode(new Origin(new URL("file:data.ttl")));

for (Map&lt;String, Node&gt; bindings : new Engine(query).lookup(data)) {
    &hellip;
}</pre>
            <p>Programs described using the RDF vocabulary are compiled and executed by Datalog engines in the context of
                an input data graph and return variables bindings or other result structures. Programs may also be
                executed interactively or as scripts using the command-line <a href="shell.html">shell</a> as described
                below.</p><h2><a class="bookmark" name="Matching" href="#@top"></a>Matching</h2><p>The basic operation of
                engines is scanning graphs for sets of edges <em>matching</em> a pattern.</p>
            <pre>[] foaf:name [].</pre>
            <p>Matches any edge having <code>foaf:</code><code>name</code> as predicate. The simplest pattern
                (<em>atom</em>) contains a single edge where literals and URI references act as constraints and blank
                nodes as free variables.</p>
            <pre>? foaf:name ?name.</pre>
            <p>Variables may be named and written as an identifier preceded by a single question mark&nbsp;('?'); a lone
                question mark is equivalent to an anonymous blank node.</p>
            <pre>? foaf:name ?x; foaf:knows [foaf:name ?y].</pre>
            <p>Patterns with multiple edges (<em>groups</em>) describe sets of atoms <em>joined</em> by shared variables.
            </p><p>
                <img style="width: 5.709708333333333cm; height: 3.099152777777778cm;" src="data:image/png;base64,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%0AnJURYAQYgf8PxKdkZh85kgEAAAAASUVORK5CYII=">
            </p><p>Groups match subgraphs containing edges matched by atoms and sharing a common node where shared
                variables appear in the pattern.</p><p>When applied to a graph, patterns produce a binding
                <em>sequence</em> containing a set of <em>bindings</em> from variables to matched nodes for each matching
                subgraph.</p><h2><a class="bookmark" name="Querying" href="#@top"></a>Querying</h2><p>Queries scan the
                input graph for subgraphs matching a pattern and for each match return a mapping from variable names
                appearing in the pattern to matched nodes.</p>
            <pre>lookup ? foaf:name ?x; foaf:knows [foaf:name ?y].</pre>
            <table cellspacing="0" class="code" style="width: 100%;">
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?x</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?y</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Libertino Faussone"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Primo Levi"</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Libertino Faussone"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Clementina Oddenino"</p></td>
                </tr>
            </table>
            <p>Retrieves the names of people involved in social relations.</p><h3>
                <a class="bookmark" name="Composing complex patterns" href="#@top"></a>Composing complex patterns</h3><p>
                Atoms and groups may be assembled into <em>composite patterns</em> using logical <em>connectives</em>.
            </p>
            <pre>lookup { ? foaf:name ?label } or { ? foaf:nick ?label }</pre>
            <table cellspacing="0" class="code" style="width: 100%;">
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?label</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Libertino Faussone"</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Primo Levi"</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Clementina Oddenino"</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Tino"</p></td>
                </tr>
            </table>
            <p>Retrieves labels that are either names or nicknames. Composite
                <a href="handbook.html#_Patterns">patterns</a> include <em>exclusion</em>,
                <em>disjunction</em><em>, </em><em>implication</em><em>,</em> <em>conjunction</em><em>,
                    assertion, </em><em>negation </em>and<em> option.</em> Braces ('{}') may be added around patterns to
                clarify or modify connective precedence.</p><h3>
                <a class="bookmark" name="Organizing matches" href="#@top"></a>Organizing matches</h3><p>Binding
                sequences produced by patterns are unordered and may contain duplicate items: sequence modifiers may be
                used to sort and select bindings.</p>
            <pre>lookup ? foaf:name ?name; foaf:age ?age by +?age</pre>
            <table cellspacing="0" class="code" style="width: 100%;">
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?name</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?age</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Libertino Faussone"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>35</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Primo Levi"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>59</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Clementina Oddenino"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>66</p></td>
                </tr>
            </table>
            <p>Retrieves names and ages sorting matches by age. The optional unary plus ('+') before the sorting
                criterion explicitly specifies ascending order. Conversely, a unary minus ('-') may be used to specify
                descending order. Multiple sorting criteria separated by commas (',') may be specified, in order of
                precedence.</p>
            <pre>lookup ? foaf:name ?name; foaf:age ?age by ?age up to 1</pre>
            <table cellspacing="0" class="code" style="width: 100%;">
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?name</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?age</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Libertino Faussone"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>35</p></td>
                </tr>
            </table>
            <p>Retrieves name and age of the youngest person. The retrieved range is specified as <code>up to &lt;length&gt;</code>
                <code>from &lt;offset&gt;</code>, using either or both modifiers. Range indexes starts from
                <code>0</code>.</p>
            <pre>lookup ?x, ?y where
    ? foaf:name ?x; foaf:interest ?interest; foaf:knows [
        foaf:name ?y; foaf:interest ?interest
    ]</pre>
            <table cellspacing="0" class="code" style="width: 100%;">
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?a</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?b</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Libertino Faussone"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Primo Levi"</p></td>
                </tr>
            </table>
            <p>Retrieves pairs of related people sharing a common interest, regardless of which one. Projecting bindings
                to a set of selected variables removes ancillary ones, such as <code>?interest</code>, from the returned
                sequence.</p>
            <pre>lookup distinct ? foaf:interest ?interest</pre>
            <table cellspacing="0" class="code" style="width: 100%;">
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?interest</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>
                        &lt;http://en.wikipedia.org/wiki/Narrative&gt;</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>
                        &lt;http://en.wikipedia.org/wiki/Chemistry&gt;</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>&lt;http://en.wikipedia.org/wiki/Construction&gt;</p>
                    </td>
                </tr>
            </table>
            <p>Retrieves the set of distinct people interests, removing duplicate bindings from the returned
                sequence.</p><h3><a class="bookmark" name="Filtering matches" href="#@top"></a>Filtering matches</h3><p>
                Binding sequences may be <em>filtered</em> according to a boolean <em>expression</em>.</p>
            <pre>lookup ? foaf:name ?name; foaf:age ?age. ?age &gt; 50</pre>
            <table cellspacing="0" class="code" style="width: 100%;">
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?name</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?age</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Primo Levi"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>59</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Clementina Oddenino"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>66</p></td>
                </tr>
            </table>
            <p>Retrieves people older than 50. <a href="handbook.html#Expressions">Expressions</a> are built from
                logical, relational and arithmetic operators and function calls, parsed with usual precedence and
                associativity rules. Parentheses may be added around expressions to clarify or modify operator
                precedence.</p><h3><a class="bookmark" name="Computing values" href="#@top"></a>Computing values</h3><p>
                Expressions may also be used to <em>compute</em> values derived from available bindings.</p>
            <pre>lookup ?name, ?birth where
    ? foaf:name ?name; foaf:age ?age.
    ?birth = 1978-?age</pre>
            <table cellspacing="0" class="code" style="width: 100%;">
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?name</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?birth</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Libertino Faussone"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>1943</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Primo Levi"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>1919</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Clementina Oddenino"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>1912</p></td>
                </tr>
            </table>
            <p>Retrieves people names and birth years, assuming 1978 as the current year <em>;-)</em></p>
            <pre>lookup ?name, ?works where
    ?author foaf:name ?name.
    ?works = count([?w where ?author foaf:made ?w])</pre>
            <table cellspacing="0" class="code" style="width: 100%;">
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?author</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?works</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Libertino Faussone"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>0</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Primo Levi"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>2</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Clementina Oddenino"</p></td>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>0</p></td>
                </tr>
            </table>
            <p>Computes the number of authored works. In their most general form, functions process and return node <em>sequences</em>,
                supporting scalar, aggregate and multi-valued call patterns. The framework provides a standard runtime
                <a href="library.html">library</a> of scalar and aggregate functions, which may be
                <a href="#_Extending_1">extended</a> with custom implementations. The runtime library includes a subset
                of the functions specified by <a href="http://www.w3.org/TR/xquery-operators/">XQuery 1.0 and XPath 2.0
                    Functions and Operators</a>.</p>
            <pre>lookup ?label = string-join of [?name, " (", ?nick, ")"] where
    ? foaf:name ?name; foaf:nick ?nick.</pre>
            <table cellspacing="0" class="code" style="width: 100%;">
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?label</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Libertino Faussone (Tino)"</p></td>
                </tr>
            </table>
            <p>Computes an extended label including name and nickname. The node sequence containing the strings to be
                joined is specified by explicitly enumerating its members and bound to the output variable directly in
                the projection target. Parentheses around single sequence arguments may be omitted or replaced by the
                <code>of</code> keyword.</p><h2><a class="bookmark" name="Inferencing" href="#@top"></a>Inferencing</h2>
            <p>Rules scan the input graph for subgraphs matching a pattern and for each match instantiate and apply a
                graph <em>template</em>. Like groups, templates contain a set of atoms joined by shared variables, but
                are intended to be instantiated, that is to be converted into actual graphs by substituting free
                variables with values read from a binding.</p><h3>
                <a class="bookmark" name="Backing queries with rules" href="#@top"></a>Backing queries with rules</h3><p>
                Datalog queries are actually part of programs, which may also include rules.</p>
            <pre>lookup ? a foaf:Person; foaf:name ?name.

insert ?agent a foaf:Person where
    ?agent foaf:knows ? or ? foaf:knows ?agent.</pre>
            <table cellspacing="0" class="code" style="width: 100%;">
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?name</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Libertino Faussone"</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Primo Levi"</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"Clementina Oddenino"</p></td>
                </tr>
            </table>
            <p>Retrieves the name of all agents that are persons. The fact that <code>"Primo Levi"</code> and <code>"Clementina
                Oddenino"</code> are persons is not explicitly stated in the input graph but rather <em>inferred</em> by
                the engine on the basis of the included rule.</p><h3>
                <a class="bookmark" name="OWL reasoning" href="#@top"></a><a name="_OWL_reasoning"></a><acronym>OWL</acronym><acronym> </acronym>reasoning
            </h3><p>Facts may also be inferred from input data on the basis of descriptive ontologies specified with the
                <a href="http://www.w3.org/TR/owl2-primer/">OWL 2</a> knowledge representation language.</p>
            <pre>@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt;.
@prefix owl:  &lt;http://www.w3.org/2002/07/owl#&gt;.
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt;.

foaf:Person a owl:Class.

foaf:knows a owl:ObjectProperty;
    rdfs:domain foaf:Person;
    rdfs:range foaf:Person.</pre>
            <p>Models the same notion described by the rule in the previous example, that is that knowing or being known
                implies being a person.</p>
            <pre>extend &lt;FOAF.owl&gt;
extend&lt;java:net.oroboro.ns#OWL-RL&gt;

lookup ? a foaf:Person; foaf:name ?name.</pre>
            <p>Retrieves the name of all agents that are persons. Again, the fact that <code>"Primo Levi"</code> and
                <code>"Clementina Oddenino"</code> are persons is not explicitly stated in the input graph but rather
                <em>inferred</em> by the engine on the basis of the extended ontology. The second extension directive
                activates a set of rules supporting reasoning with OWL ontologies using the
                <a href="http://www.w3.org/TR/owl2-profiles/#Reasoning_in_OWL_2_RL_and_RDF_Graphs_usi">OWL RL/RDF
                    rules</a> axiomatization.</p>
            <pre>Graph FOAF=new AnyDecoder()
    .decode(new Origin(new URL("file:FOAF.owl")));

for (Map&lt;String, Node&gt; bindings 
        : new Engine(query, FOAF, OWL.RL()).lookup(data)) {
    &hellip;
}</pre>
            <p>Performs the same query using an engine. Note that multiple program graphs are specified as argument to
                the engine constructor, to the same effect as the previous extension directives.</p><h2>
                <a class="bookmark" name="Updating" href="#@top"></a><a name="_Updating"></a>Updating</h2><p>Datalog
                programs may be used to declaratively update graphs.</p>
            <pre>Graph graph=new Engine(program).update(data);</pre>
            <p>Updates the input data graph by inserting all of the edges that may be inferred from existing ones as
                specified by the updating program and then removing unwanted ones.</p><h3>
                <a class="bookmark" name="Inserting edges" href="#@top"></a>Inserting edges</h3><p>In the first phase of
                the updating process, RDF statements inferred from insertion rules are iteratively inserted into the
                graph until no new statement may be inferred in the expanded context.</p>
            <pre>insert ?work dc:creator ?author where
    ? foaf:name ?author; foaf:made ?work.</pre>
            <p>Infers the name of work authors from the name of the agent that made them.</p><h3>
                <a class="bookmark" name="Removing edges" href="#@top"></a>Removing edges</h3><p>In the second phase of
                the updating process, RDF statements matched by removal rules are removed from the expanded input
                graph.</p>
            <pre>remove ?agent foaf:nick ? where
    ?agent a foaf:Person.</pre>
            <p>Removes statements about nicknames of agents the are persons.</p><h3>
                <a class="bookmark" name="Adding assumptions" href="#@top"></a>Adding assumptions</h3><p>During the
                insertion phase RDF statements are inferred taking into account existing statements both in the expanded
                graph and in the Datalog program. Facts stated in the program may be augmented with RDF statements
                inferred from assumption rules without inserting them in the expanded graph. This facility supports the
                creation of <em>ancillary</em> statements, for instance in the context of alignment processes where
                normalized literals may be used to match resources from different datasets.</p>
            <pre>insert ?x owl:sameAs ?y where
    ?x &lt;id&gt; ?id. ?y &lt;id&gt; ?id. ?x != ?y.

assume ?agent &lt;id&gt; ?id where
    ?agent foaf:name ?name; foaf:age ?age.
    ?id = string-join [?name, "/", ?age].</pre>
            <p>Infers that different descriptions refers to the same agent if they report the same name and the same age.
                Structured <em>identifiers</em> built from the concatenation of the identifying elements are assumed as a
                basis for the inference without being themselves inserted in the expanded graph.</p><h2>
                <a class="bookmark" name="Verifying" href="#@top"></a>Verifying</h2><p>Datalog programs may specify
                integrity constraints for graphs.</p>
            <pre>as nicks verify ?agent foaf:nick ? where ?agent foaf:name ?name.</pre>
            <p>Verifies that every named agent has a nickname too. For each binding produced by the <em>body</em> pattern
                the <em>head</em> pattern should match at least one subgraph. The optional label introducing the clause
                identifies it for reporting purposes.</p>
            <pre>for (final Map&lt;String, Node&gt; violation : new Engine(program).verify(data) {
    System.err.println(violation);
}</pre>
            <pre>{="nicks", agent=_:id1113757163, name="Clementina Oddenino"}
{="nicks", agent=_:id282106579, name="Primo Levi"}</pre>
            <p>Verifies that the input data graph satisfies integrity constraints specified by the program and reports
                violations as a sequence of bindings that failed to satisfy the constraint. The empty string is bound to
                the constraint identifier.</p><h2><a class="bookmark" name="Morphing" href="#@top"></a>Morphing</h2><p>
                <a href="api/index.html?net/oroboro/io/Morpher.html">Morphers</a> may directly query and update graphs
                under the control of a Datalog program.</p>
            <pre><a name="_Datatypes"></a><a name="_Datatypes_1"></a><a name="_Datatypes_2"></a><a name="_Datatypes_3"></a><a name="_Datatypes_4"></a>for (Map&lt;String, Node&gt; bindings : new Morpher()
    .decode(new Origin(new URL("file:data.ttl")))
    .lookup(new Origin(new URL("file:query.dl")))
) {
    &hellip;
}</pre>
            <p>Decodes an input graph, queries it and processes the resulting variables bindings.</p>
            <pre>new Morpher()
    .decode(new Origin(new URL("file:input.ttl")))
    .update(new Origin(new URL("file:program.dl")))
    .encode(new Target(new URL("file:output.ttl")));</pre>
            <p>Decodes a graph from an input source, updates and encodes it to an output target.</p><h2>
                <a class="bookmark" name="Extending" href="#@top"></a><a name="_Extending"></a><a name="_Extending_1"></a>Extending
            </h2><p>Suppose we wanted to generate default nicknames as lowercased acronyms of full names, for instance
                <code>"</code><code>lf</code><code>"</code> for <code>"</code><code>Libertino
                    Faussone</code><code>"</code>. The framework allows computing such specific values by means of custom
                functions called in the context of expressions.</p><h3>
                <a class="bookmark" name="Defining custom functions" href="#@top"></a>Defining custom functions</h3>
            <pre>public class FOAF {

    public static Node defaultNick(Node name) {
        if ( name == null ) { return null; } else {

            StringBuilder nick=new StringBuilder();
            
            for (String word : name.text().trim().split("\\s+")) {
                nick.append(word.charAt(0));
            }

            return new Node(nick.toString().toLowerCase());
        }
    }
}</pre>
            <p>Custom functions are implemented as static Java methods, usually taking nodes as arguments and returning a
                node as value. Illegal arguments and other error conditions are signaled by returning <code>null</code>
                values, so custom functions must be ready to accept and handle <code>null</code> arguments.</p><h3>
                <a class="bookmark" name="Calling custom functions" href="#@top"></a>Calling custom functions</h3><p>
                Within expression, custom functions are identified by the fully qualified name of the implementation
                method, reported using a URI reference with the special <code>java:</code> scheme, like:</p>
            <pre>prefix xo: &lt;java:org.example.FOAF#&gt;

insert ?agent foaf:nick ?nick where
    ?agent foaf:name ?name.
    ?nick = xo:default-nick(?name).</pre>
            <p>Computes and assigns default nicknames on the basis of full names. The scheme-specific part of the URI is
                the fully qualified name of the implementation class; the fragment the name of the implementation method.
                Method names are case-insensitive and hyphens are ignored.</p><h3>
                <a class="bookmark" name="Aggregate and multi-valued custom functions" href="#@top"></a>Aggregate and
                multi-valued custom functions</h3><p>In their most general form, custom functions process and produce
                node sequences, allowing aggregate and multi-valued functions to be defined within the same
                framework.</p>
            <pre>public static Iterator&lt;Node&gt; reverse(Iterator&lt;Node&gt; nodes) {
    if ( nodes == null ) { return null; } else {

        List&lt;Node&gt; reversed=new ArrayList&lt;Node&gt;();

        while ( nodes.hasNext() ) {
            reversed.add(0, nodes.next());
        }

        return reversed.iterator();
    }
}</pre>
            <pre>prefix xo: &lt;java:org.example.FOAF#&gt;

lookup ?x = string-join(xo:reverse(tokenize("one two three"))).</pre>
            <table cellspacing="0" class="code" style="width: 100%;">
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; border-bottom-style: solid;border-bottom-color: #BFBFBF;">
                        <p>?x</p></td>
                </tr>
                <tr>
                    <td style="padding-left: 0pt; padding-right: 3pt; "><p>"three two one"</p></td>
                </tr>
            </table>
            <p>Reverses the words in the lexical form of a node.</p><h1>
                <a class="bookmark" name="Shell" href="#@top"></a>Shell</h1><p class="note">Work in progress. Details may
                change in future releases.</p><p>On Unix systems, the command-line <a href="shell.html">shell</a> enables
                interactive and scripted execution of Datalog programs, supporting most of the functionalities previously
                introduced through the engine API. Much like morphers, the shell evaluates programs and performs I/O
                operations in the context of a working graph and a shared reference catalog for URI management.</p><h2>
                <a class="bookmark" name="Interacting" href="#@top"></a>Interacting</h2>
            <pre>% bin/oroboro

<em>Oroboro</em><em> </em><em>0.6</em><em> (</em><em>20110310</em><em>) - </em><em>Copyright &copy; 2010-2011 Alessandro Bollini</em><em>
</em><em>
This program is free software: you can redistribute it and/or modify</em><em>
it under the terms of the GNU General Public License as published by</em><em>
the Free Software Foundation, either version 3 of the License, or</em><em>
(at your option) any later version; see &lt;http://www.gnu.org/licenses/&gt;.</em><em>
</em><em>
</em>&gt; </pre>
            <p>To start an interactive shell, run the <code>bin/oroboro </code>executable under the home directory of the
                binary distribution. The executable is self-contained and may be relocated wherever it suits. To leave
                the shell execute the <code>quit</code> command or type <code>^D</code>.</p><h3>
                <a class="bookmark" name="Importing data" href="#@top"></a>Importing data</h3>
            <pre>&gt; decode &lt;data.ttl&gt;
<em>[info] decod</em><em>ed 22 statements from &lt;...</em><em>/data.ttl&gt; in 0.0 s (5.5 K/s)</em><em>
</em>&gt; </pre>
            <p>Decodes an input origin identified by a URI reference into the working graph.</p><h3>
                <a class="bookmark" name="Executing queries" href="#@top"></a>Executing queries</h3>
            <pre>&gt; lookup ? foaf:name ?name; foaf:age ?age by +?age
<em>name</em><em>: </em><em>"Libertino Faussone" age</em><em>: </em><em>"35"^^xsd:integer</em> &lt;enter&gt;
<em>name</em><em>: </em><em>"Primo Levi" age</em><em>: </em><em>"59"^^xsd:integer </em>&lt;enter&gt;<em>
</em><em>name</em><em>: </em><em>"Clementina Oddenino" age</em><em>: </em><em>"66"^^xsd:integer</em>
&gt; </pre>
            <p>Retrieves names and ages sorting matches by age. Results are listed a match at a time. If more matches are
                available, the shell pauses for user input: type <code>&lt;enter&gt;</code> to list one more match or
                <code>^D</code> to break from the loop.</p>
            <pre>&gt; lookup ? a foaf:Group; foaf:name ?name
<em>no</em>
&gt; </pre>
            <p>Retrieves group names. If no matches are found, the shell replies with <code>no</code>.</p>
            <pre>&gt; lookup ? a foaf:Person; foaf:name "Libertino Faussone"
<em>yes</em>
&gt; </pre>
            <p>Tests if a specific person is described in the working graph. If the query contains no named variables and
                one or more matches are found, the shell replies with <code>yes</code>.</p>
            <pre>&gt; lookup ?name where
?     ?agent foaf:name ?name</pre>
            <p>Typed commands may span multiple lines. To break from the secondary prompt type <code>^D</code>.</p><h3>
                <a class="bookmark" name="Updating data" href="#@top"></a>Updating data</h3>
            <pre>&gt; insert ?<em>agent</em> a foaf:Person where
    ?agent foaf:knows ? or ? foaf:knows ?agent.
<em>[info] inferred 2 statements</em>
&gt; </pre>
            <p>Infers that agents knowing or being known are persons and updates the working graph.</p><h3>
                <a class="bookmark" name="Exporting data" href="#@top"></a>Exporting data</h3>
            <pre>&gt; encode &lt;data.rdf&gt;
<em>[info] encoded </em><em>24</em><em> statements to &lt;</em><em>...</em><em>/data.rdf&gt; in 0.0 s (0.9 K/s)</em>
&gt; </pre>
            <p>Encodes the working graph into an output target identified by a URI reference.</p><h2>
                <a class="bookmark" name="Scripting" href="#@top"></a>Scripting</h2><p>The command-line shell may be used
                as a standalone converter and scripting tool.</p><h3>
                <a class="bookmark" name="Converting RDF documents" href="#@top"></a>Converting RDF documents</h3>
            <pre>% bin/oroboro data.xml &gt; data.ttl</pre>
            <p>Converts an RDF graph from RDF/XML to Turtle. When invoked with one or more arguments, the shell decodes
                their contents to the working graph and encodes it to its standard output. Arguments are interpreted as
                possibly relative URIs identifying input origins, resolved against the <code>file:</code> URI for the
                current working directory. </p>
            <pre>% bin/oroboro --rdf - --nt &lt; input &gt; output</pre>
            <p>Converts an RDF graph from RDF/XML to N-Triples. A single hyphen ('<code>-</code>') identifies the
                standard input. Format <a href="shell.html#Options">options</a> control the fallback format for the
                format <a href="#_Guessing_1">guessing</a> codecs used by the shell to decode origins and encode targets.
            </p><h3><a class="bookmark" name="Updating RDF documents" href="#@top"></a>Updating RDF documents</h3>
            <pre>% bin/oroboro --owl data.owl data.xml &gt; data.ttl</pre>
            <p>Decodes an input origin, <a href="#_OWL_reasoning">classifies</a> it under the control of an ontology
                using the <a href="handbook.html#OWL%20RL">OWL&nbsp;RL/RDF reasoner</a> and encodes the resulting graph
                to the standard output.</p>
            <pre>% bin/oroboro --dl data.dl data.ttl --rdf &gt; data.rdf</pre>
            <p>Decodes an input origin, <a href="#_Updating">updates</a> it under the control of a Datalog program and
                encodes the resulting graph to the standard output in RDF/XML format. Updating and formatting options may
                be mixed as required.</p><h1><a class="bookmark" name="Datatypes" href="#@top"></a>Datatypes</h1><p>
                <a href="api/index.html?net/oroboro/Type.html">Datatypes</a> supports bidirectional mappings between
                typed literals and Java objects representing them. The framework includes predefined implementations for
                natively supported datatypes defined in the <a href="api/index.html?net/oroboro/ns/RDF.html">RDF</a> and
                <a href="api/index.html?net/oroboro/ns/XSD.html">XSD</a> namespaces. Custom datatypes may be defined and
                registered as required and will behave on a par with native ones.</p><p>As already mentioned, every node
                has a datatype: Oroboro generalizes the standard RDF abstract model to blank nodes, URI references and
                plain literals by treating them as typed literals with an implementation-specific internal datatype.</p>
            <h2><a class="bookmark" name="Mappings" href="#@top"></a>Mappings</h2><h3>
                <a class="bookmark" name="Mapping nodes to values" href="#@top"></a>Mapping nodes to values</h3>
            <pre>XSD._int.value(new Node(123)) // .equals(123)</pre>
            <p>Returns the value represented by the lexical form of a node.</p>
            <pre>XSD._int.value((Node)null) // == null
XSD._int.value(new Node("123")) // == null (a plain literal!)
XSD._int.value(new Node("text", XSD._int)) // == null (malformed!)</pre>
            <p>If the node is <code>null</code> or has an incompatible datatype or its lexical form doesn't belong to the
                lexical space of the datatype, the value is <code>null</code>.</p><h3>
                <a class="bookmark" name="Mapping values to nodes" href="#@top"></a>Mapping values to nodes</h3>
            <pre>XSD._int.node(123) // .equals(new Node(123))</pre>
            <p>Returns a typed literal node with a lexical form representing a value.</p>
            <pre>XSD._unsignedInt.node((Integer)null) // == null
XSD._unsignedInt.node(-123) // == null (out of range!)</pre>
            <p>If the value is <code>null</code> or doesn't belong to the value space of the datatype, the node is <code>null</code>.
            </p><h3><a class="bookmark" name="Mapping nodes to lexical forms" href="#@top"></a>Mapping nodes to lexical
                forms</h3>
            <pre>XSD._int.text(new Node(123)) // .equals("123")</pre>
            <p>Returns the canonical lexical form of a node.</p>
            <pre>XSD._int.text((Node)null) // == null
XSD._int.text(new Node("123")) // == null (a plain literal!)
XSD._int.text(new Node("text", XSD._int)) // == null (malformed!)</pre>
            <p>If the node is <code>null</code> or has an incompatible datatype or its lexical form doesn't belong to the
                lexical space of the datatype, the lexical form is <code>null</code>.</p><h3>
                <a class="bookmark" name="Mapping lexical forms to nodes" href="#@top"></a>Mapping lexical forms to nodes
            </h3>
            <pre>XSD._int.node("123") // .equals(new Node(123))</pre>
            <p>Returns a node with a canonical lexical form.</p>
            <pre>XSD._int.node((String)null) // == null
XSD._int.node("text") // == null (malformed!)</pre>
            <p>If the lexical form is <code>null</code> or doesn't belong to the lexical space of the datatype, the node
                is <code>null</code>.</p><h3><a class="bookmark" name="Mapping lexical forms to values" href="#@top"></a>Mapping
                lexical forms to values</h3>
            <pre>XSD._int.value("123") // .equals(123)</pre>
            <p>Returns the value represented by a lexical form.</p>
            <pre>XSD._int.value((String)null) // == null
XSD._int.value("text") // == null (malformed!)</pre>
            <p>If the lexical form is <code>null</code> or doesn't belong to the lexical space of the datatype, the value
                is <code>null</code>.</p><h3><a class="bookmark" name="Mapping values to lexical forms" href="#@top"></a>Mapping
                values to lexical forms</h3>
            <pre>XSD._unsignedInt.text(123) // .equals("123")</pre>
            <p>Returns the canonical lexical form of a value.</p>
            <pre>XSD._unsignedInt.text(null) // == null
XSD._unsignedInt.text(-123) // == null (out of range!)</pre>
            <p>If the value is <code>null</code> or doesn't belong to the value space of the datatype, the lexical form
                is <code>null</code>.</p><h2><a class="bookmark" name="Inheritance" href="#@top"></a>Inheritance</h2><p>
                Datatypes may be related to each other by inheritance relations, meaning that a typed literal belonging
                to a datatype <em>derived by restriction </em>must be considered as belonging as well to the
                <em>base</em> datatype.</p>
            <pre>XSD._int.restricts(XSD._decimal) // == true
XSD._int.restricts(XSD._boolean) // == false</pre>
            <p>Tests if a datatype is derived by restriction from a base datatype.</p>
            <pre>XSD._int.restricts(XSD._int) // == true</pre>
            <p>The value space of a datatype is an improper subset of itself, so each datatypes is considered to be
                derived from itself.</p>
            <pre>new Node(123).isTyped(XSD._int) // == true
new Node(123).isTyped(XSD._decimal) // == true</pre>
            <p>Because of inheritance, typed literals with a derived datatype belong as well to the base datatype.</p>
            <h2>
                <a class="bookmark" name="Plugging" href="#@top"></a><a name="_Customization"></a><a name="_Plugging"></a>Plugging
            </h2><p>Suppose we wanted to track user ratings in a serialized RDF graph using small integers in the range
                from 0&nbsp;to&nbsp;5. To convey the specific semantics of the literal, we would define a dedicated
                datatype in our vocabulary and use it to type literals like:</p>
            <pre>@prefix xo: &lt;http://example.org/schema#&gt;.

[] dc:title "La chiave a stella";
    dc:description "4"^^xo:Rating.</pre>
            <pre>Node r=new Node("4", URI.create("http://example.org/schema#Rating"));</pre>
            <p>However, the new datatype has no special meaning to the framework and its numeric nature is lost, as well
                as the fact that its values could be conveniently represented by Java integers.</p>
            <pre>r.isNumeric() // == false
r.value().equals(4) // == false</pre>
            <p>To provide this information to the framework we should create and register a custom datatype object, as
                outlined in the following sections.</p><h3>
                <a class="bookmark" name="Resolving datatype URIs" href="#@top"></a>Resolving datatype
                <acronym>URI</acronym>s</h3>
            <pre>Type.lookup(URI.create("http://www.w3.org/2001/XMLSchema#int")) // == XSD._int</pre>
            <p>Datatypes are uniquely identified by an absolute URI: while parsing serialized RDF graphs, decoders
                convert datatype URIs to type objects by looking them up in a global datatype <em>registry</em>. The
                registry is initialized with natively supported datatypes defined in the
                <a href="api/index.html?net/oroboro/ns/RDF.html">RDF</a> and
                <a href="api/index.html?net/oroboro/ns/XSD.html">XSD</a> namespaces and it's dynamically extended as new
                datatypes are resolved. </p>
            <pre>Type&lt;String&gt; data=Type.create(URI.create("http://example.org/schema#data"))</pre>
            <p>If no matching datatype is currently available, a new datatype is created and registered. The new datatype
                is identified by the specified URI and has an identity lexical/value mapping, that is its value and its
                lexical form are represented by the same string object.</p><p>Hence, to support rating literals we need
                to create and register the custom datatype object before the datatype URI is first resolved, that is
                before decoding graphs or creating nodes referencing it.</p><h3>
                <a class="bookmark" name="Defining datatype objects" href="#@top"></a>Defining datatype objects</h3>
            <pre>public class Rating extends Type&lt;Integer&gt; {
    &hellip;
}</pre>
            <p>Custom datatypes are instances of classes derived from a common abstract
                <a href="api/index.html?net/oroboro/Type.html">base</a>. The generic parameter specifies the type of the
                Java objects datatype values are mapped to. </p>
            <pre>public Rating(final URI uri) { super(uri, XSD._int); }</pre>
            <p>Concrete type classes may describe themselves as derived by restriction from a base datatype. The <code>Rating</code>
                datatype describe itself as derived by the XSD <code>int</code> datatype. Types are immutable
                value-objects: after initialization they are never altered and compare equal if their URIs are equal.</p>
            <pre>@Override public Integer value(final CharSequence text) {
    try {
        return text == null ? null : filter(Integer.valueOf(text.toString()));
    } catch ( final NumberFormatException ignored ) {
        return null;
    }
}

@Override public String text(final Integer value) {
    return filter(value) == null ? null : Integer.toString(value);
}

private Integer filter(final Integer value) {
    return value != null &amp;&amp; value &gt;= 0 &amp;&amp; value &lt;= 5 ? value : null;
}</pre>
            <p>Concrete type classes must implement basic mappings between lexical forms and values. Mappings involving
                nodes are provided by the base class. Null values and exceptions must be handled to support malformed
                lexical forms. <a href="api/net/oroboro/Type.html#convert(net.oroboro.Node)">Conversion</a> and
                <a href="api/net/oroboro/Type.html#promote(net.oroboro.Node)">promotion</a> methods may be overridden to
                define custom casting and promotion rules.</p><h3>
                <a class="bookmark" name="Registering datatype objects" href="#@top"></a>Registering datatype objects
            </h3><p>To activate a custom datatype, an instance of its defining class must be created and registered
                before its datatype URI is first resolved.</p>
            <pre>public static final Type&lt;Integer&gt; Rating=Type.register(
        new Rating(URI.create("http://example.org/schema#Rating")));</pre>
            <p>A convenient way to perform this step is to define the datatype as a constant in a utility namespace
                class, alongside constants defining companion terms as URI reference nodes.</p><h3>
                <a class="bookmark" name="Custom datatypes in action" href="#@top"></a>Custom datatypes in action</h3>
            <pre>Node r=new Node("4", URI.create("http://example.org/schema#Rating"));</pre>
            <pre>r.type() instanceof Rating // == true</pre>
            <p>After being registered, custom datatypes are resolved and behave exactly like native ones.</p>
            <pre>r.isNumeric() // == true (!)
r.value().equals(4) // == true (!)</pre>
            <p>Rating literals are now correctly recognized as numeric and converted to integers.</p>
            <pre>Node node=Rating.node(4) // .equals(new Node("4", Rating))
Integer value=Rating.value(node) // == 4</pre>
            <p>Custom datatypes lack dedicated node constructors and strictly typed value retrieval methods available for
                core XSD types in the node API: however, such conversions may be conveniently performed using type
                constants.</p></div>
        <div class="footer links">
            <a class="side" href="http://www.linkedin.com/in/alessandrobollini"><img src="http://www.linkedin.com/img/webpromo/btn_in_20x15.png" width="16" height="12" alt="Alessandro Bollini's LinkedIn profile"></a>
            <div>Copyright &copy; 2010-2011 Alessandro Bollini</div>
        </div>
    </body>
</html>